module pointedMaps where

import bool

compPathRefl (A : U) (a b : A) (p : Path A a b) : Path (Path A a b) (compPath A a b b p (<_> b)) p =
  <i j> hcomp A (p @ j) [(i = 1) -> <_> p @ j, (j = 0) -> <_> a, (j = 1) -> <_> b]

compPathRefl' (A : U) (a b : A) (p : Path A a b) : Path (Path A a b) (compPath A a a b (<_> a) p) p =
  <i j> hcomp A a [(i = 1) -> <k> p @ (j /\ k), (j = 0) -> <_> a, (j = 1) -> <k> p @ k]

compPathRefl'' (A : U) (a b : A) (p : Path A a b) :
  Square A a b b b (compPath A a a b (<_> a) p) (<_> b) p (<_> b) =
  <i j> hcomp A a [(i = 0) -> <k> p @ (j /\ k), (i = 1) -> <k> p @ k, (j = 1) -> <k> p @ k]

compPathReflRefl (A : U) (a : A) : Path (Path A a a) (compPath A a a a (<_> a) (<_> a)) (<_> a) =
 compPathRefl A a a (<_> a)


-- Pointed types
pType : U = (X : U) * X

pt (Z : pType) : Z.1 = Z.2

-- Maps between pointed types
ppi' (A : pType) (B : A.1 -> U) (b0 : B (pt A)) : U = (f : (a : A.1) -> B a) * Path (B (pt A)) (f (pt A)) b0
ppi (A : pType) (B : A.1 -> pType) : U = ppi' A (\(a : A.1) -> (B a).1) (pt (B (pt A)))
pmap (A B : pType) : U = ppi A (\(a : A.1) -> B)

pid (A : pType) : pmap A A = (\(a : A.1) -> a, <_> pt A)

pcompose (A B C : pType) (g : pmap B C) (f : pmap A B) : pmap A C =
  (\(a : A.1) -> (g.1 (f.1 a)), compPath C.1 (g.1 (f.1 (pt A))) (g.1 (pt B)) (pt C) (<i> g.1 (f.2 @ i)) g.2)

-- constant pointed map
pconst (A B : pType) : pmap A B = (\(a:A.1) -> pt B, <_> pt B )

ppmap (A B : pType) : pType = (pmap A B, pconst A B)

ppcompose (A B C : pType) (f : pmap B C) : pmap (ppmap A B) (ppmap A C) =
  (pcompose A B C f, <i> (\(a : A.1) -> f.2 @ i, <j> compPathRefl'' C.1 (f.1 B.2) C.2 f.2 @ j @ i))

pppcompose (A B C : pType) : pmap (ppmap B C) (ppmap (ppmap A B) (ppmap A C)) =
  (ppcompose A B C,
   <i> (\(f : pmap A B) -> (\(a : A.1) -> C.2, compPathReflRefl C.1 C.2 @ i),
        <j> (\(a : A.1) -> C.2,
             <k> hcomp C.1 C.2 [(k=0) -> <_> C.2, (k=1) -> <_> C.2, (i=1) -> <_> C.2, (j=1) -> <_> C.2])))

passoc (A B C D : pType) (h : pmap C D) (g : pmap B C) (f : pmap A B) :
  Path (pmap A D) (pcompose A C D h (pcompose A B C g f)) (pcompose A B D (pcompose B C D h g) f) =
  undefined

-- pointed equivalence
pequiv (A B : pType) : U = (f : pmap A B) * isEquiv A.1 B.1 f.1

pbool : pType = (bool, false)

pathPmap (A B : pType) (f g : pmap A B) (p : (a : A.1) -> Path B.1 (f.1 a) (g.1 a))
  (q : Square B.1 (f.1 A.2) (g.1 A.2) B.2 B.2 (p A.2) (<_> B.2) f.2 g.2) : Path (pmap A B) f g =
  <i> (\(a : A.1) -> p a @ i, <j> q @ i @ j)

-- first test case: pointed maps from the booleans to A are the same as points in A
ppmapBoolEquiv (A : pType) : pequiv (ppmap pbool A) A = (e, h) where
  B : U = pmap pbool A
  e1 : B -> A.1 = \(h : B) -> h.1 true
  p : Path A.1 (e1 (pconst pbool A)) (pt A) = <_> pt A
  e : pmap (ppmap pbool A) A = (e1, p)
  inv : A.1 -> B = \(a : A.1) -> (caseBool A.1 (pt A) a, <_> (pt A))
  q (a : A.1) : Path A.1 (e1 (inv a)) a = <_> a
  r (f : B) : Path B (inv (e1 f)) f =
    <i> (\(b : bool) -> indBool (\(b : bool) -> Path A.1 ((inv (e1 f)).1 b) (f.1 b))
                                (<i> f.2 @ -i)
                                (<_> f.1 true) b @ i,
          <j> f.2 @ (-i \/ j))
  h : isEquiv B A.1 e.1 = gradLemma B A.1 e.1 inv q r

-- reversing the arguments of a binary pointed map
revPpmap (A B C : pType) : pmap (ppmap A (ppmap B C)) (ppmap B (ppmap A C)) = (e1, e0) where
  bc  : U = pmap B C
  ac  : U = pmap A C
  abc : U = pmap A (ppmap B C)
  bac : U = pmap B (ppmap A C)
  BC  : pType = ppmap B C
  AC  : pType = ppmap A C
  ABC : pType = ppmap A (ppmap B C)
  BAC : pType = ppmap B (ppmap A C)
  e111 (f : abc) (b : B.1) (a : A.1) : C.1 = (f.1 a).1 b
  e110 (f : abc) (b : B.1) : Path C.1 (e111 f b (pt A)) (pt C) = <i> (f.2 @ i).1 b
  e11 (f : abc) (b : B.1) : ac = (e111 f b, e110 f b)
  e10 (f : abc) : Path ac (e11 f (pt B)) (pconst A C) =
    <i> (\(a : A.1) -> (f.1 a).2 @ i, <j> (f.2 @ j).2 @ i)
  e1 (f : abc) : bac = (e11 f, e10 f)
  e0 : Path bac (e1 (pconst A BC)) (pconst B AC) =
    <_> pconst B AC

revRevPpmap (A B C : pType) (f : pmap A (ppmap B C)) :
  Path (pmap A (ppmap B C)) ((revPpmap B A C).1 ((revPpmap A B C).1 f)) f = <_> f

revRevPpmap2 (A B C : pType) :
  Path (pmap (ppmap A (ppmap B C)) (ppmap A (ppmap B C)))
       (pcompose (ppmap A (ppmap B C)) (ppmap B (ppmap A C)) (ppmap A (ppmap B C))
                 (revPpmap B A C) (revPpmap A B C))
       (pid (ppmap A (ppmap B C))) = p where
  bc  : U = pmap B C
  ac  : U = pmap A C
  abc : U = pmap A (ppmap B C)
  bac : U = pmap B (ppmap A C)
  BC  : pType = ppmap B C
  AC  : pType = ppmap A C
  ABC : pType = ppmap A (ppmap B C)
  BAC : pType = ppmap B (ppmap A C)
  BC0 : bc = pconst B C
  ABC0 : abc = pconst A BC
  s   : pmap ABC BAC = revPpmap A B C
  si  : pmap BAC ABC = revPpmap B A C
  ss  : pmap ABC ABC = pcompose ABC BAC ABC si s
  p2  : Path (Path abc ABC0 ABC0) ss.2 (<_> ABC0) = compPathReflRefl abc ABC0
  p   : Path (pmap ABC ABC) ss (pid ABC) = pathPmap ABC ABC ss (pid ABC) (refl abc) p2

symmPpmap (A B C : pType) : pequiv (ppmap A (ppmap B C)) (ppmap B (ppmap A C)) =
  (revPpmap A B C, gradLemma (pmap A (ppmap B C)) (pmap B (ppmap A C))
    (revPpmap A B C).1 (revPpmap B A C).1 (revRevPpmap B A C) (revRevPpmap A B C))

pentagon (A B C D : pType) :
  Path (pmap (ppmap A (ppmap B C)) (ppmap B (ppmap (ppmap D A) (ppmap D C))))
  (pcompose (ppmap A (ppmap B C)) (ppmap B (ppmap A C)) (ppmap B (ppmap (ppmap D A) (ppmap D C)))
            (ppcompose B (ppmap A C) (ppmap (ppmap D A) (ppmap D C)) (pppcompose D A C))
            (revPpmap A B C))
  (pcompose (ppmap A (ppmap B C)) (ppmap (ppmap D A) (ppmap B (ppmap D C))) (ppmap B (ppmap (ppmap D A) (ppmap D C)))
            (revPpmap (ppmap D A) B (ppmap D C))
            (pcompose (ppmap A (ppmap B C)) (ppmap (ppmap D A) (ppmap D (ppmap B C))) (ppmap (ppmap D A) (ppmap B (ppmap D C)))
                      (ppcompose (ppmap D A) (ppmap D (ppmap B C)) (ppmap B (ppmap D C)) (revPpmap D B C))
                      (pppcompose D A (ppmap B C)))) = p where
  DA  : pType = ppmap D A
  DC  : pType = ppmap D C
  BC  : pType = ppmap B C
  AC  : pType = ppmap A C
  ABC : pType = ppmap A BC
  BAC : pType = ppmap B AC
  DBC : pType = ppmap D BC
  BDC : pType = ppmap B DC
  DADC : pType = ppmap DA DC
  DADBC : pType = ppmap DA DBC
  DABDC : pType = ppmap DA BDC
  BDADC : pType = ppmap B DADC
  bc  : U = pmap B C
  ac  : U = pmap A C
  abc : U = pmap A BC
  bdadc : U = pmap B DADC
  X : U = pmap ABC BDADC
  -- bac : U = pmap B AC
  -- BC0 : bc = pconst B C
  ABC0 : abc = pconst A BC
  BDADC0 : bdadc = pconst B DADC
  s   : pmap ABC BAC = revPpmap A B C
  s2  : pmap DABDC BDADC = revPpmap DA B DC
  -- si  : pmap BAC ABC = revPpmap B A C
  -- ss  : pmap ABC ABC = pcompose ABC BAC ABC si s
  -- p2  : Path (Path abc ABC0 ABC0) ss.2 (<_> ABC0) = compPathReflRefl abc ABC0
  BDarrow : pmap BAC BDADC = ppcompose B AC DADC (pppcompose D A C)
  DAs : pmap DADBC DABDC = ppcompose DA DBC BDC (revPpmap D B C)
  LHS : X = pcompose ABC BAC BDADC BDarrow s
  RHS : X = pcompose ABC DABDC BDADC s2 (pcompose ABC DADBC DABDC DAs (pppcompose D A BC))
  lhs (f : abc) : bdadc = BDarrow.1 (s.1 f)
  rhs (f : abc) : bdadc = s2.1 (DAs.1 ((pppcompose D A BC).1 f))

  p1 (f : abc) : Path bdadc (lhs f) (rhs f) =
    undefined
  p2  : Square bdadc (lhs ABC0) (rhs ABC0) BDADC0 BDADC0 (p1 ABC0) (<_> BDADC0) LHS.2 RHS.2 =
    undefined
  p   : Path X LHS RHS = pathPmap ABC BDADC LHS RHS p1 p2

  -- p2  : Path (Path abc ABC0 ABC0) ss.2 (<_> ABC0) = compPathReflRefl abc ABC0
  -- p   : Path (pmap ABC ABC) ss (pid ABC) = pathPmap ABC ABC ss (pid ABC) (refl abc) p2

-- pathPmap (A B : pType) (f g : pmap A B) (p : (a : A.1) -> Path B.1 (f.1 a) (g.1 a))
--   (q : Square B.1 (f.1 A.2) (g.1 A.2) B.2 B.2 (p A.2) (<_> B.2) f.2 g.2) : Path (pmap A B) f g =
--   <i> (\(a : A.1) -> p a @ i, <j> q @ i @ j)
